---
title: Getting Started
description: Step-by-step guide showing how to use SSO Kit in your application.
order: 100
---
:react:
// tag::content[]

== Getting Started with SSO Kit
:sectnums:

SSO Kit builds upon https://spring.io/projects/spring-boot[Spring Boot] and https://spring.io/projects/spring-security[Spring Security]. It comes with a starter module that configures the security settings needed to authenticate with your identity provider.

== Create a Hilla Application

To create a Hilla application without authentication, use this command:

----
npx @hilla/cli init --react <your-project-name>
----

include::{root}/articles/lit/guides/tools/sso-kit/getting-started.adoc[tag=serverside]

=== Use the Endpoint

Start the application using the `./mvnw` command (`.\mvnw` on Windows), so that Hilla generates TypeScript files.

Then, start adding authentication to the front-end. The first step is to add some state using a `Context`. In the [filename]`frontend` folder, add a file named [filename]`useAuth.tsx` with this content:

[source,typescript]
----
import { createContext } from "react";
import User from "./generated/dev/hilla/sso/endpoint/User";
import type SingleSignOnData from "./generated/dev/hilla/sso/starter/SingleSignOnData";
import { SingleSignOnEndpoint, UserEndpoint } from "./generated/endpoints";

type AuthState = Readonly<{ user?: User } & SingleSignOnData>;

const initialState: AuthState = {
    user: await UserEndpoint.getAuthenticatedUser(),
    ...(await SingleSignOnEndpoint.getData()),
};

export type AccessProps = Readonly<{
    requiresLogin?: boolean;
    rolesAllowed?: readonly string[];
}>;

type AccessCheck = ({ handle }: { handle: AccessProps }) => boolean;

export type Authentication = Readonly<{
    state: AuthState;
    hasAccess: AccessCheck;
}>;

const hasAccess = (state: AuthState): AccessCheck => {
    return ({ handle }: { handle: AccessProps }) => {
        const requiresAuth = handle.requiresLogin || handle.rolesAllowed;
        if (!requiresAuth) {
            return true;
        }

        if (!state.user) {
            return false;
        }

        if (handle.rolesAllowed) {
            return handle.rolesAllowed.some((allowedRole) => state.user!.roles.includes(allowedRole));
        }

        return true;
    }
}

export const AuthContext = createContext<Authentication>({
    state: initialState,
    hasAccess: hasAccess(initialState),
});
----

Now open the [filename]`frontend/routes.tsx` file and add the newly created `AccessProps` type to `ViewMeta` like so:

[source,typescript]
----
export type ViewMeta = Readonly<{ handle?: MenuProps & AccessProps }>;
----

Then protect the `about` view by adding `requiresLogin: true` to it.

[source,typescript]
----
{ path: '/about', element: <AboutView />, handle: { icon: 'la la-file', title: 'About', requiresLogin: true  } },
----

Most of the code changes go into the [filename]`frontend/views/MainLayout.tsx` file. First, use the `Context` created earlier:

[source,typescript]
----
const { state, hasAccess } = useContext(AuthContext);
----

Then filter the menu items so that the `about` view disappears when not authenticated:

[source,typescript]
----
{menuRoutes.filter(hasAccess).map(({ path, handle: { icon, title } }) => (
----

Next, add some interface items in the footer to allow users to log in and out of the application:

[source,jsx]
----
<footer slot="drawer">
  {state.user ? (
    <>
      <div className="flex items-center gap-m">
        {state.user.fullName}
      </div>
      <Button onClick={logout}>Sign out</Button>
    </>
  ) : (
    <a href={state.loginUrl}>Sign in</a>
  )}
</footer>
----

Implement the `logout` function called on click:

[source,typescript]
----
import { logout as _logout } from '@hilla/frontend';

async function logout() {
  await _logout(); // perform logout on the application server
  location.href = state.logoutUrl!;
}
----

As the `about` view is now reserved to authenticated users, you can add some user information to it like so:

[source,typescript]
----
const { state } = useContext(AuthContext);
----

[source,jsx]
----
<p>Username: {state.user!.preferredUsername}</p>
<p>Full name: {state.user!.fullName}</p>
<p>Email: {state.user!.email}</p>
<p>Roles: {state.user!.roles?.join(', ')}</p>
----

All of these changes should be picked up automatically. To be sure, try logging in, navigating, and logging out.

include::{root}/articles/lit/guides/tools/sso-kit/getting-started.adoc[tag=singlesignoff]

==== Modify the Client Application

There is a chance that users won't want to leave the application abruptly when a logout notification arrives. For example, they may be concerned with losing something that's still in process. That's why more state management is needed.

To address this potential problem, to support back-channel logout, the [filename]`useAuth.tsx` created earlier needs more functionality. To do this, replace that file with this version:

[source,typescript]
----
import { Subscription } from "@hilla/frontend";
import { createContext, Dispatch, SetStateAction, useState } from "react";
import User from "./generated/dev/hilla/sso/endpoint/User";
import Message from "./generated/dev/hilla/sso/starter/BackChannelLogoutSubscription/Message";
import type SingleSignOnData from "./generated/dev/hilla/sso/starter/SingleSignOnData";
import { BackChannelLogoutEndpoint, SingleSignOnEndpoint, UserEndpoint } from "./generated/endpoints";

export type AuthState = Readonly<SingleSignOnData & {
    user?: User,
    backChannelLogout?: Subscription<Message>,
    backChannelLogoutHappened: boolean,
}>;

type AccessCheck = ({ handle }: { handle: AccessProps }) => boolean;

export type Authentication = Readonly<{
    state: AuthState;
    clearUserInfo: () => void;
    onBackChannelLogout: () => void;
    hasAccess: AccessCheck;
}>;

export const initialState = await (async () => {
    const authInfo = await SingleSignOnEndpoint.getData();
    const backChannelLogout = authInfo.backChannelLogoutEnabled
        ? BackChannelLogoutEndpoint.subscribe() : undefined;

    return {
        user: await UserEndpoint.getAuthenticatedUser(),
        backChannelLogout,
        backChannelLogoutHappened: false,
        ...authInfo,
    };
})();

export type AccessProps = Readonly<{
    requiresLogin?: boolean;
    rolesAllowed?: readonly string[];
}>;

const hasAccess = (state: AuthState): AccessCheck => {
    return ({ handle }: { handle: AccessProps }) => {
        const requiresAuth = handle.requiresLogin || handle.rolesAllowed;
        if (!requiresAuth) {
            return true;
        }

        if (!state.authenticated) {
            return false;
        }

        if (handle.rolesAllowed) {
            return handle.rolesAllowed.some((allowedRole) => state.roles.includes(allowedRole));
        }

        return true;
    }
}

export const AuthContext = createContext<Authentication>({
    state: initialState,
    clearUserInfo: () => { },
    onBackChannelLogout: () => { },
    hasAccess: hasAccess(initialState),
});

export const useAuth = (state: AuthState, setState: Dispatch<SetStateAction<AuthState>>): Authentication => {
    return {
        state,
        clearUserInfo: () => {
            setState({
                ...state,
                user: undefined,
                logoutUrl: undefined,
                authenticated: false,
                roles: [],
                backChannelLogout: undefined,
                backChannelLogoutHappened: false,
                backChannelLogoutEnabled: false,
            });
        },
        onBackChannelLogout: () => {
            setState({
                ...state,
                backChannelLogoutHappened: true,
            });
        },
        hasAccess: hasAccess(state),
    };
}
----

As for the state, it can be put in [filename]`App.tsx`:

[source,jsx]
----
export default function App() {
  const [state, setState] = useState<AuthState>(initialState);

  return <AuthContext.Provider value={useAuth(state, setState)}>
    <RouterProvider router={router} />
  </AuthContext.Provider >;
}
----

Finally, modify [filename]`MainLayout.tsx` again to act on logout notifications coming from the server:

[source,typescript]
----
const { state, hasAccess, onBackChannelLogout, clearUserInfo } = useContext(AuthContext);

useEffect(() => {
  if (state.backChannelLogout) {
    state.backChannelLogout.onNext(() => {
      onBackChannelLogout();
    });
  }
}, []);
----

Now, add a dialog to ask users if they want to log in again:

[source,jsx]
----
<ConfirmDialog header='Logged out' cancel opened={!!state.backChannelLogoutHappened}
  onConfirm={loginAgain} onCancel={stayOnPage}>
  <p>You have been logged out. Do you want to log in again?</p>
</ConfirmDialog>
----

You can implement the two functions used by the dialog like this:

[source,typescript]
----
async function loginAgain() { 
  await _logout();
  location.href = state.loginUrl;
}

async function stayOnPage() { 
  await _logout();
  clearUserInfo();
}
----

// end::content[]
