---
title: Getting Started
description: Step-by-step guide showing how to use SSO Kit in your application.
order: 100
---
:lit:
// tag::content[]

== Getting Started with SSO Kit
:sectnums:

SSO Kit builds upon https://spring.io/projects/spring-boot[Spring Boot] and https://spring.io/projects/spring-security[Spring Security]. It comes with a starter module that configures the security settings needed to authenticate with your identity provider.

== Create a Hilla Application without Authentication

You can create a Hilla application by entering the following from the command-line:

----
npx @hilla/cli init <your-project-name>
----

// tag::serverside[]

== Add the SSO Kit Dependency

Add the `sso-kit-starter` module and other required dependencies to the [filename]`pom.xml` of your Vaadin application like so:

.[filename]`pom.xml`
[source,xml]
----
<dependency>
    <groupId>dev.hilla</groupId>
    <artifactId>sso-kit-starter</artifactId>
    <version>2.0.0.alpha2</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----

== Configure the SSO Provider in Spring

Next, you need to set some configuration properties to connect SSO Kit to your OpenID Connect provider. These properties can be added to your [filename]`application.properties` file where you define the provider URL and the client registration details, such as credentials and scope.

Provider definition is configured within the `spring.security.oauth2.provider` namespace where you define a key to identify your provider, such as `keycloak`. Then you can use the same key to register the client for that provider within the `spring.security.oauth2.registration` namespace, where you specify client credentials and the requested scope.

The scope is a list of keywords to request the provider for a specific set of information, such as user `profile`, `email` or `roles`. The following is an example of the properties to set to enable a Keycloak instance to perform authentication:

[.example]
--
.[filename]`application.properties`
[source,properties]
----
vaadin.sso.login-route=/oauth2/authorization/keycloak
spring.security.oauth2.client.registration.keycloak.scope=profile,openid,email,roles
# Customize the values of the following properties according to your Keycloak configuration
spring.security.oauth2.client.provider.keycloak.issuer-uri=https://my-keycloak.io/realms/my-realm
spring.security.oauth2.client.registration.keycloak.client-id=my-client
spring.security.oauth2.client.registration.keycloak.client-secret=very-secret-value
----
.[filename]`application.yaml`
[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: https://my-keycloak.io/realms/my-realm
        registration:
          keycloak:
            client-id: my-client
            client-secret: very-secret-value
            scope:
            - profile
            - openid
            - email
            - roles
vaadin:
  sso:
    login-route: /oauth2/authorization/keycloak
----
--

== Securing Views

=== Add a Hilla Endpoint

A [classname]`SingleSignOnEndpoint` is already included in the kit. To use it, you must enable the new Hilla <<{articles}lit/reference/configuration#java-compiler-options, multi-module engine>>. The easiest way to enable it is to create or modify the [filename]`vaadin-featureflags.properties` file and add this line:

.src/main/resources/vaadin-featureflags.properties
[source,properties]
----
com.vaadin.experimental.hillaEngine=true
----

Optionally, if you want to get user information or to have a message about the back-channel logout, you can use the [classname]`UserEndpoint` and the [classname]`BackChannelLogoutEndpoint` too.

By default, the package name in generated Hilla projects is `com.example.application`. Unless you use the same package name as for your application, you have to whitelist your package in Spring Boot for Hilla to be able to find the Endpoint. Open your [filename]`Application.java` and add the package to the annotation like this:

.[filename]`Application.java`
[source,java]
----
@SpringBootApplication(scanBasePackages = {
  "com.example.application", // Application package
  "dev.hilla.sso" // SSO Kit
})
public class Application // ...
----

=== Protect the Endpoint

Hilla allows fine-grained authorization on Endpoints and Endpoint methods. You can use annotations like `@PermitAll` or `@RolesAllowed(...)` to declare who can access what.

To try this feature, replace the `@AnonymousAllowed` annotation in [filename]`HelloWorldEndpoint.java` with `@PermitAll`, so that unauthenticated users will be unable to access the whole Endpoint. You could also apply the same annotation at the method level.

Start the application using the `./mvnw` command (`.\mvnw` on Windows), so that Hilla generates TypeScript files.

Try the application in the browser. It should work correctly, except that when you click on the `Say hello` button, nothing happens. This is because the Endpoint is no longer accessible without authentication.

// end::serverside[]

=== Implement Authentication State

To implement authentication state, inside the `AppStore` class in [filename]`app-store.ts`, add this code:

[source,typescript]
----
user: User | undefined = undefined;
loginUrl: string | undefined = undefined;
logoutUrl: string | undefined = undefined;

async fetchAuthInfo() {
  const authInfo = await SingleSignOnEndpoint.getData();
  this.loginUrl = authInfo.loginUrl;
  this.logoutUrl = authInfo.logoutUrl;
  this.user = await UserEndpoint.getAuthenticatedUser();
}

clearUserInfo() {
  this.user = undefined;
  this.logoutUrl = undefined;
}

get loggedIn() {
  return !!this.user;
}

isUserInRole(role: string) {
  return this.user?.roles?.includes(role);
}
----

You should be able to add the missing imports, automatically.

Open the [filename]`frontend/index.ts` file and delay the router setup until the login information has been fetched by wrapping the `setRoutes` call as follows:

[source,typescript]
----
appStore.fetchAuthInfo().finally(() => {
  // Ensure router access checks are not done before we know if we are logged in
  router.setRoutes(routes);
});
----

=== Add Access Control

To add access control to the existing routes, open the [filename]`frontend/routes.ts` file and enrich the `ViewRoute` type:

[source,typescript]
----
export type ViewRoute = Route & {
  title?: string;
  icon?: string;
  children?: ViewRoute[];
  // add the following two properties
  requiresLogin?: boolean;
  rolesAllowed?: string[];
};
----

The `rolesAllowed` property is not used in this example. However, it's good to have it since it can protect views according to user roles. For example, `rolesAllowed: ['admin', 'manager']` must be configured in the SSO provider.

Next add a function to find whether the user has access to the requested view:

[source,typescript]
----
export const hasAccess = (route: Route) => {
  const viewRoute = route as ViewRoute;
  if (viewRoute.requiresLogin && !appStore.loggedIn) {
    return false;
  }

  if (viewRoute.rolesAllowed) {
    return viewRoute.rolesAllowed.some((role) => appStore.isUserInRole(role));
  }
  return true;
};
----

Now modify the `about` path so that it requires login and redirects to the SSO Login page if needed like this:

[source,typescript]
----
{
  path: 'about',
  icon: 'la la-file',
  title: 'About',
  action: async (_context, _command) => {
    return hasAccess(_context.route) ? _command.component('about-view') : _command.redirect('login');
  },
  requiresLogin: true,
},
----

Then add a `login` route to the exported `routes` (not `views`) like so:

[source,typescript]
----
{
  path: 'login',
  icon: '',
  title: 'Login',
  action: async (_context, _command) => {
    _command.redirect(appStore.loginUrl!);
  },
},
----

=== Add Login and Logout

To add login and logout to the interface, open [filename]`frontend/views/main-layout.ts` and add a login/logout button in the `footer`:

[source,html]
----
<footer slot="drawer">
  ${appStore.user
    ? html`
        <div className="flex items-center gap-m">
          ${appStore.user.fullName}
        </div>
        <vaadin-button @click="${this.logout}">Sign out</vaadin-button>
      `
    : html`<a router-ignore href="${appStore.loginUrl!}">Sign in</a>`
  }
</footer>
----

Next, add the needed functions like this:

[source,typescript]
----
import { logout as _logout } from '@hilla/frontend';

private async logout() {
  await _logout(); // Logout on the server
  location.href = appStore.logoutUrl!; // Logout on the provider
}
----

Filter out protected views from the menu by modifying the `getMenuRoutes` function as shown here:

[source,typescript]
----
private getMenuRoutes(): RouteInfo[] {
  return views.filter((route) => route.title).filter(hasAccess) as RouteInfo[];
}
----

Try to customize your views further, for example to change the root view to not use `hello-world`, which is protected, or to add a new view.

Next, test the application: log in, log out, and try to use the Endpoint by clicking on the "Say hello" button in both cases.

// tag::singlesignoff[]

== Single Sign-Off

SSO Kit provides two methods for logging out the user. It's defined by the OpenID Connect specification like so:

- https://openid.net/specs/openid-connect-rpinitiated-1_0.html[RP-Initiated Logout]
- https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel Logout]

=== RP-Initiated Logout

RP-Initiated Logout (i.e., Relaying Party, the application) enables the user to logout from the application itself, ensuring the connected provider session is terminated.

After a successful logout, the user is redirected to the configured logout redirect route. That can be set with the `vaadin.sso.logout-redirect-route` property:

[.example]
--
.application.properties
[source,properties]
----
vaadin.sso.logout-redirect-route=/logout-successful
----
.application.yaml
[source,yaml]
----
vaadin:
  sso:
    logout-redirect-route: /logout-successful
----
--

The default value of this property is the application root.

=== Back-Channel Logout

Back-Channel Logout is a feature that enables the provider to close user sessions from outside the application. For example, it can be done from the provider's user dashboard or from another application.

==== Enable the Feature

To enable the feature in the application, you need to set the `vaadin.sso.back-channel-logout` property to `true`. You would do this like you see here:

[.example]
--
.[filename]`application.properties`
[source,properties]
----
vaadin.sso.back-channel-logout=true
----
.[filename]`application.yaml`
[source,yaml]
----
vaadin:
  sso:
    back-channel-logout: true
----
--

The client should then be configured on the provider's dashboard to send logout requests to a specific application URL: `/logout/back-channel/{registration-key}`, where `{registration-key}` is the provider key.

==== Enable Push Support

To be able to get logout notifications from the server in real time, add this line to [filename]`vaadin-featureflags.properties`:

----
com.vaadin.experimental.hillaPush=true
----

Now restart your application to enable Push support.

// end::singlesignoff[]

==== Modify the Client Application

Open [filename]`app-store.ts` again and add the following properties:

[source,typescript]
----
backChannelLogoutEnabled = false;
backChannelLogoutHappened = false;
private logoutSubscription: Subscription<Message> | undefined;
----

Add more code to the `fetchAuthInfo` and `clearUserInfo` functions to store values and subscribe to notifications:

[source,typescript]
----
async fetchAuthInfo() {
  const authInfo = await SingleSignOnEndpoint.getData();
  this.loginUrl = authInfo.loginUrl;
  this.logoutUrl = authInfo.logoutUrl;
  this.backChannelLogoutEnabled = authInfo.backChannelLogoutEnabled;

  this.user = await UserEndpoint.getAuthenticatedUser();

  if (this.user && this.backChannelLogoutEnabled) {
    this.logoutSubscription = BackChannelLogoutEndpoint.subscribe();

    this.logoutSubscription.onNext(() => {
      this.backChannelLogoutHappened = true;
    });
  }
}

clearUserInfo() {
  this.user = undefined;
  this.logoutUrl = undefined;
  this.backChannelLogoutHappened = false;

  if (this.logoutSubscription) {
    this.logoutSubscription.cancel();
    this.logoutSubscription = undefined;
  }
}
----

Now, go to [filename]`main-layout.ts` and add a Confirm Dialog to notify the user, just above the empty `slot`:

[source,typescript]
----
import '@vaadin/confirm-dialog';

<vaadin-confirm-dialog
  header="Logged out"
  cancel-button-visible
  @confirm="${this.loginAgain}"
  @cancel="${this.stayOnPage}"
  .opened="${appStore.backChannelLogoutHappened}"
>
  <p>You have been logged out. Do you want to log in again?</p>
</vaadin-confirm-dialog>
----

Next, add the related functions like so:

[source,typescript]
----
private async stayOnPage() {
  await _logout(); // Logout on the server
  appStore.clearUserInfo(); // Logout on the client
}

private async loginAgain() {
  await _logout(); // Logout on the server
  location.href = appStore.loginUrl!;
}
----

To test this functionality, you need to log into the application, then close your session externally. For example, you might do this from the Keycloak administration console.

// end::content[]
